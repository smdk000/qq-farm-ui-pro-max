<!DOCTYPE html>
<html lang="zh-CN" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>系统高阶优化方案设计 (Plan_DoubleCheck_Advance)</title>
    <style>
        :root {
            --bg: #0f172a;
            --text: #f1f5f9;
            --glass: rgba(30, 41, 59, 0.7);
            --border: rgba(51, 65, 85, 0.5);
            --primary: #3b82f6;
            --danger: #ef4444;
        }

        body {
            margin: 0;
            padding: 2rem;
            font-family: -apple-system, system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .card {
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2 {
            color: var(--primary);
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .code-block {
            background: #1e293b;
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            overflow-x: auto;
            font-size: 0.9em;
            border: 1px solid var(--border);
        }

        .highlight {
            color: #38bdf8;
            font-weight: bold;
        }

        .warning {
            color: #f87171;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }
    </style>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'dark' });
    </script>
</head>

<body>
    <div class="container">
        <h1>高阶架构优化设计书 (Advanced Optimizations V2)</h1>

        <div class="card">
            <h2>一、背景上下文</h2>
            <p>基于 <code>v3.2.9</code> 用户先行落地的 <code>sendMsgAsyncUrgent</code> (使用 unshift 插队) 和 冗余 sleep
                清理。该基础打得很好，但我们在高并发微秒级抢收场景下，依然有进一步升华的空间。</p>
        </div>

        <div class="card">
            <h2>二、优化改造 1: 真正有序的 Priority 优先级发包队列</h2>
            <div class="grid">
                <div>
                    <h3>痛点 (为何不用 unshift)</h3>
                    <p>如果连续 3 块土地近乎同毫秒成熟，发起：<br>
                        1. 土地A `getAllLandsUrgent`<br>
                        2. 土地B `getAllLandsUrgent`</p>
                    <p>通过单纯的 <code>unshift</code> 会导致 <strong>倒序 (LIFO)</strong>，后发的 B 会强行把前发的 A
                        压向后面，打乱了底层的微时序连贯性，甚至会拆散原本应该连续执行的事件链。</p>
                </div>
                <div>
                    <h3>重构发包队列为 Dual-Queue (双通列)</h3>
                    <div class="code-block">
                        const normalQueue = [];
                        const urgentQueue = []; // FIFO 有序高优

                        function enqueueSend(task) { normalQueue.push(task); }
                        function enqueueSendUrgent(task) { urgentQueue.push(task); }

                        // 消费侧优先抽空 urgent
                        const task = urgentQueue.length > 0
                        ? urgentQueue.shift()
                        : normalQueue.shift();
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>三、优化改造 2: API 短时合并防御 (Coalescing Micro-Cache)</h2>
            <div class="grid">
                <div>
                    <h3>痛点 & 数据洪流</h3>
                    <p>在 `antiStealHarvest` 中如果同时触发 5 块地的保护机制（由于 `getLands` 时延或批量成熟）。每个地的防偷函数都会分别发起一次
                        `getAllLandsUrgent()`，这会在 1.6 秒内狂轰 5 次极高负载且携带 64 块土地信息的相同 Protobuf 响应包，易触发风控。</p>
                </div>
                <div>
                    <h3>解决方案 (Promise 级合并)</h3>
                    <p>构建微秒级 (如 500ms 内) 的 <strong>Promise 共享池</strong>。当一个获取农田状态请求处于 Pending 状态时，其它并行的查询全部挂载到同一个
                        Promise 身上。只用 1 个包喂饱 5 个抢收并发逻辑。</p>
                </div>
            </div>

            <h3>架构流图 (Promise 合并)</h3>
            <pre class="mermaid">
sequenceDiagram
    participant LandA as AntiSteal(A)
    participant LandB as AntiSteal(B)
    participant Cache as Promise Cache (farm.js)
    participant Net as Network (TokenBucket)
    participant Srv as Tencent Server

    LandA->>Cache: 1. getAllLandsUrgent()
    Cache->>Net: 发起网络查询
    LandB->>Cache: 2. getAllLandsUrgent() (时延 <100ms)
    Cache-->>LandB: 拦截! 发现请求正在飞行中，返回同一个 Promise
    Net->>Srv: 耗时物理发包 (1次)
    Srv-->>Net: 返回所有土地实况
    Net-->>Cache: 成功解析的土地 Array
    Cache-->>LandA: 齐步 Resolve()
    Cache-->>LandB: 齐步 Resolve()
            </pre>
        </div>

        <div class="card">
            <h2>四、影响面分析 (Impact Analysis)</h2>
            <ul>
                <li><span class="highlight">网络层 (network.js)</span>：由于改变的是内部结构（将 `sendQueue` 分为两个原生队列），完全前向兼容，不对任何业务 API
                    (`sendMsgAsync`) 的入参或出参造成改变，退散性归零。</li>
                <li><span class="highlight">业务层 (farm.js)</span>：通过模块级变量拦截了高频的并发探测，由于只缓存区区
                    `500ms`（防抖级别的防洪），不存在土地状态滞后过时的问题，完美兼顾了数据实时性。</li>
            </ul>
        </div>
    </div>
</body>

</html>