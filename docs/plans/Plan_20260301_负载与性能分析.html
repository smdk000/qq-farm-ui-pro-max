<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>系统负载与性能瓶颈分析测试方案</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: #1e293b;
            --border-color: #334155;
            --text-main: #f1f5f9;
            --text-muted: #94a3b8;
            --accent: #3b82f6;
            --danger: #ef4444;
            --warning: #f59e0b;
            --success: #10b981;
        }
        body {
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            line-height: 1.6;
            margin: 0;
            padding: 2rem;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        h1, h2, h3 { color: #fff; margin-top: 2rem; }
        h1 { border-bottom: 2px solid var(--accent); padding-bottom: 0.5rem; }
        .card {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .highlight { color: var(--accent); font-weight: 600; }
        .flex-row { display: flex; gap: 1.5rem; flex-wrap: wrap; }
        .col { flex: 1; min-width: 300px; }
        table {
            width: 100%; border-collapse: collapse; margin-top: 1rem;
        }
        th, td {
            padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border-color);
        }
        th { background-color: rgba(255,255,255,0.05); }
        .badge {
            padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.85em; font-weight: bold;
        }
        .badge.danger { background: rgba(239, 68, 68, 0.2); color: var(--danger); }
        .badge.warning { background: rgba(245, 158, 11, 0.2); color: var(--warning); }
        .badge.success { background: rgba(16, 185, 129, 0.2); color: var(--success); }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚀 农场智能助手 - 系统负载与性能分析报告</h1>
        <p style="color: var(--text-muted)">本报告旨在解答多用户大并发场景下的系统瓶颈问题、理论负载上限估算以及压力测试方案。</p>

        <div class="card">
            <h2>一、 概念解惑：前端卡顿 vs 后端崩溃</h2>
            <div class="flex-row">
                <div class="col">
                    <h3 style="color: var(--warning)">🖥️ 前端浏览器 (WebWorker建议的场景)</h3>
                    <p>当你说“用户挂了非常多个QQ”，如果这个用户打开面板，网页需要瞬间渲染上万条日志、或者弹出一个包含 5000 个好友的列表进行全选过滤。此时，**卡顿的是他的浏览器标签页**，影响的只是他个人的浏览体验，网页可能会弹出“页面无响应”。</p>
                    <p><em>这就是为什么建议将海量数据过滤放入 WebWorker（前端子线程），防止点界面时卡住。</em></p>
                </div>
                <div class="col">
                    <h3 style="color: var(--danger)">⚙️ 后端服务器 (死机/崩溃的场景)</h3>
                    <p>如果成百上千个 QQ 都在服务器内部跑定时器、同时发起 HTTP 请求偷菜、同时疯狂写入 SQLite 数据库，此时消耗的是 **服务器的 CPU 和 内存**。如果服务器算力耗尽，所有人的号都会停止偷菜，极端情况下 Node.js 进程内存溢出 (OOM) 导致整体坠毁。</p>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>二、 后端承载力估算模型 (理论极限)</h2>
            <p>Node.js 是单线程非阻塞架构，处理 I/O (网络请求) 极度高效，但在面对大批量复杂计算或海量对象占用时会有瓶颈。核心评估指标如下：</p>
            
            <table>
                <thead>
                    <tr>
                        <th>硬件维度</th>
                        <th>消耗模型预估 (单账号)</th>
                        <th>主要瓶颈诱因</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>内存 (RAM)</strong></td>
                        <td>约 <code>15MB - 30MB</code> (持有的好友列表、缓存对象、日志池)</td>
                        <td><span class="badge danger">内存溢出 OOM</span> 当账号量过大，常驻内存超 1.5GB 时，V8引擎 GC 重度工作导致停顿。</td>
                    </tr>
                    <tr>
                        <td><strong>CPU (算力)</strong></td>
                        <td>约 <code>0.1% - 0.5%</code> 核心使用率 (解析大体积JSON，定时器轮询)</td>
                        <td><span class="badge warning">事件循环延迟</span> 上千个账号同时触发定时器解析好友农场，会导致 CPU 跑满，偷菜延迟严重。</td>
                    </tr>
                    <tr>
                        <td><strong>磁盘 I/O</strong></td>
                        <td>低频状态持久化，但日志输出极高频</td>
                        <td><span class="badge danger">SQLite 数据库锁表</span> 多人同时修改配置或巨量日志同时写入单文件时引发 <code>SQLITE_BUSY</code>。</td>
                    </tr>
                </tbody>
            </table>

            <h3>📊 具体服务器规格估算（仅理论保守参考值）：</h3>
            <ul>
                <li><strong>入门级服务器 (1核 CPU / 2G 内存)</strong>: 扣除系统占用，剩余 ~1.2G 可用。预计极具稳定性挂载极限为： <span class="highlight">30 ~ 50 个满配活跃账号</span>。</li>
                <li><strong>标准级服务器 (4核 CPU / 8G 内存)</strong>: 需要开启 Node.js 的 <code>--max-old-space-size=4096</code>，预计挂载极限为： <span class="highlight">200 ~ 300 个账号</span>（此时 CPU 和 SQLite 锁表将成为首要瓶颈）。</li>
            </ul>
            <p><em>注意：以上预估基于农户24小时火力全开的高频轮询。如果很多账号只种菜不偷菜，负载能力可轻松翻 3-5 倍。</em></p>
        </div>

        <div class="card">
            <h2>三、 真实压力测试方案 (如何知道最高负载？)</h2>
            <p>理论终归是理论，如果我们要获得准确的最大负载，不需要真人去找一千个QQ号，我们需要编写一份<strong>压测模拟脚本 (Stress Testing Script)</strong>：</p>
            <ol>
                <li><strong>Mock Server (伪造腾讯接口)</strong>：在本地启动一个假的腾讯农场服务器，只要请求过去，就瞬间返回假的好友列表和植物成熟 JSON 数据。</li>
                <li><strong>虚拟账号注入</strong>：向测试用的 <code>farm-bot.db</code> 瞬间注入 500 个虚拟账号凭证，并全部启动。</li>
                <li><strong>指标监控 (PM2 / Clinic.js)</strong>：在旁边使用 Node.js 性能监控工具采集此时的 CPU 使用率、内存使用率。</li>
                <li><strong>找出崩溃点</strong>：观察系统在第几个账号加入时，出现网络错误 (Socket 拥塞)、内存爆出、或者 SQLite 报 <code>BUSY</code> 错误。</li>
            </ol>
        </div>

        <div class="card">
            <h2>四、 如果真要做万人级商业化，还需要怎么改？</h2>
            <p>如果未来你的项目定位是支撑千人、万人级别的大型群控分发，现在的架构必须做以下演进：</p>
            <table style="margin-top: 10px;">
                <tr>
                    <td style="width: 40%"><strong>1. 抛弃 SQLite，转向 Redis + MySQL</strong></td>
                    <td>SQLite 面对上千人的瞬时队列和状态写入注定锁死。需使用 Redis 暂存状态，MySQL 异步落盘。</td>
                </tr>
                <tr>
                    <td><strong>2. 多进程架构 (PM2 Cluster / K8s)</strong></td>
                    <td>单一 Node.js 进程只利用了 1 个 CPU 核心。必须启动与 CPU 核心数相同的 N 个进程，将账号平摊到不同的进程上运行。</td>
                </tr>
                <tr>
                    <td><strong>3. 前端 WebWorker 改造</strong></td>
                    <td>上千个账号带来的几万条日志流向网页，主线程必崩溃。用 WebWorker 在后台将日志 HTML 生成好，再一次性塞入屏幕。</td>
                </tr>
            </table>
        </div>
    </div>
</body>
</html>
