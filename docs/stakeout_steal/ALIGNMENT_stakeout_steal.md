# ALIGNMENT: 蹲守偷菜功能 (Stakeout Stealing)

## 1. 需求背景
目前本项目的“自动偷菜”功能（`friend_steal`）是在执行 `checkFriends()` 农场巡查时，遍历好友列表，若果实已经成熟（并且满足过滤条件），则进行偷取。
这存在明显的“时延”痛点：由于好友巡查有固定的时间间隔（配置中一般 10s 或更长），且遍历好友需要时间，很大概率在巡查到具有成熟果实的好友时，果实已被其他使用秒偷脚本的玩家偷走。

因此，用户希望增加一个 **“蹲守偷菜”** 机制：
1. **嗅探成熟时间**：在平时的大循环巡查好友农场遇到未成熟果实时，记录下这些果实的“剩余成熟时间”。
2. **建立蹲守任务**：如果剩余时间较短（例如两小时内），则在本地预留一个定时触发器（Timer）。
3. **提前踩点**：在果实成熟“前几秒”主动访问进入该好友的农场（模拟真实玩家提前打开好友农场等待）。
4. **延迟偷取**：为了避免被系统风控为“秒偷外挂”或被好友举报，在果实真正成熟之后，“延迟 X 秒”（该 X 支持用户在界面上自行滑动或输入配置）再发送 `Harvest` 偷取请求。
5. **动态配置**：该开关及防护（延迟秒数）应作为一项配置放入 `StealSettings` 偷菜设置页，并持久化到云端/本地。

## 2. 现状分析
从核心代码可以看出：
1. **循环扫田**：`friend.js` 的 `checkFriends` 和 `visitFriend`，调用 `enterFriendFarm` 进入好友农场，并 `analyzeFriendLands` 分析地块状态，此时已经计算了 `matureInSec`（还有多少秒成熟）。
2. **任务调度**：`scheduler.js` 提供了 `setTimeoutTask` 功能，支持根据 namespace 阻止任务重叠或取消。
3. **设置界面**：`web/src/views/StealSettings.vue` 已经是专门控制“偷菜过滤名单/开关”的页面，且通过 `settingStore` 与后端双向解耦交互。数据结构在 `localSettings.automation` 下面扩展即可。
4. **并发控制**：在“踩点”访问时，可能与现有的 `friendCheckLoop` 或者 `farmCheckLoop` 发生冲突，需要对全局并发有所考量。不过目前各个网络请求之间是由 Token Bucket 做的请求频控，我们只需要用正常的 `enterFriendFarm` -> `sleep` -> `stealHarvest` -> `leaveFriendFarm` 即可。

## 3. 设计分歧与决策确认
- **触发时间窗口**：是不是所有未来生长的果实都建蹲守 Timer？
  如果一个果实 10 小时后成熟，建 Timer 存活太长且 Worker 可能期间重启。
  *建议决策*：只要在 Worker 生命周期内，可以全部放入 Memory Map 管理，或者使用 `setTimeoutTask` 调度。`scheduler.js` 的底层是原生 `setTimeout`，可以支持很长的时间。我们通过在扫描好友农场时动态计算 `matureInSec`，如果有并且符合偷取条件，我们就设置/更新一个 Timer。
- **多次扫描导致的同 Timer 覆盖**：
  *建议决策*：如果下次扫描时发现倒计时依旧，且之前建立了同样的 `stakeout_gid_time` 任务，可以进行覆盖。由于植物可能施肥提前成熟，这种重新检测覆盖刚好完美纠正提前成熟的误差。
- **踩点提前量**：成熟前几秒进入农场？
  *建议决策*：默认提前 3 秒进入（`-3s`），在这 3 秒内的进程 `Sleep` 阻塞。
- **蹲守分组优化**：如果一个好友有几块地差不多时间成熟（例如偏差不超过 1 分钟）？
  *建议决策*：可以将成熟秒数按时间块划归到同一个 Timer 批处理，但为了代码健壮，我们只要在即将成熟时进去并在此时通过 `sleep` 进行守候即可。实际上，针对同一好友同一时刻（秒级）的任务分组在一起就可以了。
- **与黑白名单的兼容性**：
  *建议决策*：记录即将成熟的果实时，也必须过一遍 `shouldStealPlant` 和 `shouldStealFriend` 的过滤，不符合的不予蹲守。
