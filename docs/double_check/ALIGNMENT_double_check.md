# 6A 阶段: Align (对齐) - 防偷施肥二次校验 (Double Check)

## 1. 业务需求背景
在上一迭代中我们实现了“60秒防偷施肥”功能，采用内存长驻的 `setTimeoutTask` 机制。经过评估，当实际到达唤醒点时，如果土地经过人为的提前干预（如已抢收并种了需要很长时间成熟的新种子），定时器仍旧会被错误地执行。我们需要引入**防御性编程**，在触发瞬间对植物实际状态进行实时对账（Double Check）。

## 2. 核心目标声明
- **核心目标**: 在执行 `antiStealHarvest` 的第一行代码处，阻断不必要的、非预期的化肥消耗。
- **验证范围**:
  1. 当前作物必须处于"生长中"且未死亡的状态。
  2. 距离真正的成熟时间必须在允许的操作范围内（例如：大于 0 且小于 65 秒）。
- **非侵入式**: 改动仅限增加防呆拦截判断，不能破坏原有正常的倒计时逻辑，且不应产生多余的网络损耗（若能复用缓存尽量复用，否则应安全调用一次精准状态获取接口 `getAllLands()`）。

## 3. 技术约束与歧义解答
- **数据源获取**: 在回调触发时，最安全的做法是**强拉一次最新全量地块数据**（耗时约十多毫秒），而不是依赖可能过期的缓存。因为这是 60 秒的极限操作，时间对我们并不紧张，安全比极速的毫秒级更重要。
- **时序考量**: 拉取一次 `getAllLands()` 然后判断，如果符合条件则顺势进行 `fertilize` 和 `harvest`。此时耗费的几十毫秒完全在宽容度（60秒）内。

## 4. 产出文档约定
- `docs/double_check/ALIGNMENT_double_check.md` (本文档)
- `docs/plans/Plan_20260228_DoubleCheck.html` (架构与执行计划渲染图)
- `docs/double_check/TASK_double_check.md` (原子拆解任务单)

**结论：无业务逻辑歧义，确认按照强校验模式介入 `antiStealHarvest` 的入口即可。**
